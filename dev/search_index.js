var documenterSearchIndex = {"docs":
[{"location":"similarities/jaccard/#Jaccard-similarity-1","page":"Jaccard similarity","title":"Jaccard similarity","text":"","category":"section"},{"location":"similarities/jaccard/#","page":"Jaccard similarity","title":"Jaccard similarity","text":"warning: Under construction\nThis section is currently being developed. If you're interested in helping write this section, feel free to open a pull request; otherwise, please check back later.","category":"page"},{"location":"performance/#Performance-tips-1","page":"Performance tips","title":"Performance tips","text":"","category":"section"},{"location":"performance/#","page":"Performance tips","title":"Performance tips","text":"warning: Under construction\nThis section is currently being developed. If you're interested in helping write this section, feel free to open a pull request; otherwise, please check back later.","category":"page"},{"location":"similarities/lp_distance/#\\ellp-distance-1","page":"ell^p distance","title":"ell^p distance","text":"","category":"section"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"warning: Under construction\nThis section is currently being developed. If you're interested in helping write this section, feel free to open a pull request; otherwise, please check back later.","category":"page"},{"location":"similarities/lp_distance/#Definition-1","page":"ell^p distance","title":"Definition","text":"","category":"section"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"ell^p distance is a generalization of our usual notion of distance between a pair of points. If you're not familiar with it, you can think of it as a generalization of the Pythagorean theorem: if we have two points (a_1b_1) and (a_2b_2), then the distance between them is","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"textdistance = sqrt(a_1 - b_1)^2 + (a_2 - b_2)^2","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"This is known as the ell^2 distance (or Euclidean distance) between (a_1b_1) and (a_2b_2). In higher dimensions, the ell^2 distance between the points x = (x_1ldotsx_n) and y = (y_1ldotsy_n) is denoted as x - y_ell^2 (since ell^2 distance, and, for that matter, all ell^p distances of order ge 1, are norms) and defined as[1]","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"x - y_ell^2 = sqrtsum_i=1^n leftx_i - y_iright^2","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"More generally, the ell^p distance between the two length-n vectors x and y is given by","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"x - y_ell^p = left(sum_i=1^n leftx_i - y_iright^pright)^1p","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"In the LSHFunctions module, you can calculate the ell^p distance between two points using the function ℓp. The functions ℓ1 and ℓ2 are also defined for ell^1 and ell^2 distance, respectively, since they're so commonly used:","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"julia> using LSHFunctions;\n\njulia> x = [1, 2, 3]; y = [4, 5, 6];\n\njulia> ℓ1(x,y) == ℓp(x,y,1) == abs(1-4) + abs(2-5) + abs(3-6)\ntrue\n\njulia> ℓ2(x,y) == ℓp(x,y,2) == √(abs(1-4)^2 + abs(2-5)^2 + abs(3-6)^2)\ntrue","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"You can also compute the ell^p-norm of a vector (x_ell^p, or equivalently x - 0_ell^p) by calling ℓ1_norm, ℓ2_norm, or ℓp_norm:","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"julia> x = [1, 2, 3];\n\njulia> ℓ1_norm(x) == ℓ1(x,zero(x))\ntrue\n\njulia> ℓ2_norm(x) == ℓ2(x,zero(x))\ntrue\n\njulia> ℓp_norm(x,2.2) == ℓp(x,zero(x),2.2)\ntrue","category":"page"},{"location":"similarities/lp_distance/#LpHash-1","page":"ell^p distance","title":"LpHash","text":"","category":"section"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"This module defines L1Hash and L2Hash to hash vectors on their ell^1 and ell^2 distances. It is based on Datar et al. (2004)[Datar04], who use the notion of a p-stable distribution to construct their hash function. Such distributions exist for all p such that 0  p le 2; the LSH family of Datar et al. (2004)[Datar04] is able to hash vectors on their ell^p distance for all p in this range.","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"info: Limitations on p\nThe LSHFunctions package currently only supports hashing ell^p distances of order p = 1 and p = 2 due to some additional complexity involved with sampling p-stable distributions of different orders. This problem has been filed under issue #18.","category":"page"},{"location":"similarities/lp_distance/#Using-[L1Hash](@ref)-and-[L2Hash](@ref)-1","page":"ell^p distance","title":"Using L1Hash and L2Hash","text":"","category":"section"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"Currently only p = 1 and p = 2 are supported. You can construct hash functions for ell^1 distance and ell^2 distance using L1Hash and L2Hash:","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"julia> hashfn = L1Hash();\n\njulia> n_hashes(hashfn)\n1\n\njulia> hashfn = L2Hash(10);\n\njulia> n_hashes(hashfn)\n10","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"To hash a vector, simply call hashfn(x). Note that the hashes returned by an LpHash type such as L1Hash or L2Hash are signed integers:","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"julia> hashfn = L2Hash(128);\n\njulia> hashtype(hashfn)\nInt32\n\njulia> x = rand(20);\n\njulia> hashes = hashfn(x);\n\njulia> typeof(hashes)\nArray{Int32,1}","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"L1Hash and L2Hash support a keyword parameter called scale. scale impacts the collision probability: if scale is large then hash collisions are more likely (even among distant points). If scale is small, then hash collisions are less likely (even among close points).","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"julia> x = rand(10); y = rand(10);\n\njulia> hashfn_1 = L1Hash(128; scale=0.1);  # Small value of scale\n\njulia> n_collisions_1 = sum(hashfn_1(x) .== hashfn_1(y));\n\njulia> hashfn_2 = L1Hash(128; scale=10.);  # Large value of scale\n\njulia> n_collisions_2 = sum(hashfn_2(x) .== hashfn_2(y));\n\njulia> n_collisions_2 > n_collisions_1\ntrue","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"Good values of scale will depend on your dataset. If your data points are very far apart then you will likely want to choose a large value of scale; if they're tightly packed together then a small value is generally better. You can use the collision_probability function to help you choose a good value of scale.","category":"page"},{"location":"similarities/lp_distance/#Collision-probability-1","page":"ell^p distance","title":"Collision probability","text":"","category":"section"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"The probability that two vectors x and y collide under a hash function sampled from the LpHash family is","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"Prh(x) = h(y) = int_0^r frac1cf_pleft(fractcright)left(1 - fractrright) hspace015cm dt","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"where","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"r is the reciprocal of the scale factor used by LpHash, i.e. r = 1/scale;\nc = x - y_ell^p; and\nf_p is the p.d.f. of the absolute value of the p-stable distribution used to construct the hash.","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"The most important ideas to take away from this equation are that the collision probability Prh(x) = h(y) increases as scale increases (or, equivalently, as r increases), and that it decreases as x - y_ell^p increases. The figure below visualizes the relationship between ell^p distance and collision probability for p = 1 (left) and p = 2 (right).","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"using PyPlot, LSHFunctions\nfig, axes = subplots(1, 2, figsize=(12,6))\nrc(\"font\", size=12)\nx = range(0, 3; length=256)\n\nfor scale in (0.25, 1.0, 4.0)\n  l1_hashfn = L1Hash(; scale=scale)\n  l2_hashfn = L2Hash(; scale=scale)\n\n  y1 = [collision_probability(l1_hashfn, xii) for xii in x]\n  y2 = [collision_probability(l2_hashfn, xii) for xii in x]\n\n  axes[1].plot(x, y1, label=\"\\$r = $scale\\$\")\n  axes[2].plot(x, y2, label=\"\\$r = $scale\\$\")\nend\n\naxes[1].set_xlabel(raw\"$\\|x - y\\|_{\\ell^1}$\", fontsize=20)\naxes[1].set_ylabel(raw\"$Pr[h(x) = h(y)]$\", fontsize=20)\naxes[2].set_xlabel(raw\"$\\|x - y\\|_{\\ell^2}$\", fontsize=20)\n\naxes[1].set_title(\"Collision probability for L1Hash\")\naxes[2].set_title(\"Collision probability for L2Hash\")\n\nfor ax in axes\n  ax.legend(fontsize=14)\nend\n\nsavefig(\"lphash_collision_probability.svg\")","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"(Image: Probability of collision for L1Hash and L2Hash)","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"For further information about the collision probability, see Section 3.2 of the reference paper[Datar04].","category":"page"},{"location":"similarities/lp_distance/#Footnotes-1","page":"ell^p distance","title":"Footnotes","text":"","category":"section"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"[1]: In general, x and y are allowed to be complex vectors. We sum over leftx_i - y_iright (the magnitude of x_i - y_i) instead of (x_i - y_i)^2 to guarantee that x - y_ell^2 is a real number even when x and y are complex.","category":"page"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"[Datar04]: Datar, Mayur & Indyk, Piotr & Immorlica, Nicole & Mirrokni, Vahab. (2004). Locality-sensitive hashing scheme based on p-stable distributions. Proceedings of the Annual Symposium on Computational Geometry. 10.1145/997817.997857.","category":"page"},{"location":"lshfunction_api/#The-LSHFunction-API-1","page":"The LSHFunction API","title":"The LSHFunction API","text":"","category":"section"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"warning: Under construction\nThis section is currently being developed. If you're interested in helping write this section, feel free to open a pull request; otherwise, please check back later.","category":"page"},{"location":"lshfunction_api/#LSHFunction-1","page":"The LSHFunction API","title":"LSHFunction","text":"","category":"section"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"The LSH module exposes a relatively easy interface for constructing new hash functions. Namely, you call LSHFunction with ","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"the similarity function you want to use;\nthe number of hash functions you want to generate; and\nkeyword parameters specific to the LSH function family that you're sampling from.","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"LSHFunction(similarity, n_hashes::Integer=1; kws...)","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"For instance, in the snippet below we create a single hash function corresponding to cosine similarity:","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"julia> using LSHFunctions\n\njulia> hashfn = LSHFunction(cossim);\n\njulia> typeof(hashfn)\nSimHash{Float32}\n\njulia> n_hashes(hashfn)\n1\n\njulia> similarity(hashfn)\ncossim (generic function with 2 methods)","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"As another example, following code snippet creates 10 hash functions for inner product similarity. All of the generated hash functions are bundled together into a single SignALSH struct. We specify the following keyword arguments:","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"dtype: the data type to use internally in the SignALSH struct.\nmaxnorm: an upper bound on the norm of the data points we're hashing, and a required parameter for SignALSH.","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"julia> using LSHFunctions\n\njulia> hashfn = LSHFunction(inner_prod, 10; dtype=Float64, maxnorm=5.0);\n\njulia> n_hashes(hashfn)\n10\n\njulia> typeof(hashfn)\nSignALSH{Float64}\n\njulia> hashfn.maxnorm\n5.0","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"info: Creating multiple hash functions\nIn practice, you usually want to use multiple hash functions at the same time, and combine their hashes together in order to form a key with which to index into the hash table. To create N hash functions simultaneously, run hashfn = LSHFunction(similarity, N; kws...)hashfn will automatically generate and compute N different hash functions. It will then return a Vector of those hashes (unless hashtype(hashfn) is Bool, in which case it will return a BitArray).See the FAQ for the reasoning behind using multiple locality-sensitive hash functions simultaneously.","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"If you want to know what hash function will be created for a given similarity, you can use lsh_family:","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"julia> lsh_family(jaccard)\nMinHash\n\njulia> lsh_family(ℓ1)\nL1Hash","category":"page"},{"location":"lshfunction_api/#Utilities-1","page":"The LSHFunction API","title":"Utilities","text":"","category":"section"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"LSHFunctions.jl provides a few common utility functions that you can use across LSHFunction subtypes:","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"n_hashes: returns the number of hash functions computed by an LSHFunction.","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"julia> hashfn = LSHFunction(jaccard);\n\njulia> n_hashes(hashfn)\n1\n\njulia> hashfn = LSHFunction(jaccard, 10);\n\njulia> n_hashes(hashfn)\n10\n\njulia> hashes = hashfn(randn(50));\n\njulia> length(hashes)\n10","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"similarity: returns the similarity function for which the input LSHFunction is locality-sensitive:","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"julia> hashfn = LSHFunction(cossim);\n\njulia> similarity(hashfn)\ncossim (generic function with 2 methods)","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"hashtype: returns the type of hash computed by the input hash function. Note that in practice hashfn(x) (or index_hash(hashfn,x) and query_hash(hashfn,x) for an AsymmetricLSHFunction) will return an array of hashes, one for each hash function you generated. hashtype is the data type of each element of hashfn(x).","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"julia> hashfn = LSHFunction(cossim, 5);\n\njulia> hashtype(hashfn)\nBool\n\njulia> hashes = hashfn(rand(100));\n\njulia> typeof(hashes)\nBitArray{1}\n\njulia> typeof(hashes[1]) == hashtype(hashfn)\ntrue","category":"page"},{"location":"lshfunction_api/#","page":"The LSHFunction API","title":"The LSHFunction API","text":"collision_probability: returns the probability of collision for two inputs with a given similarity. For instance, the probability that a single MinHash hash function causes a collision between inputs A and B is equal to jaccard(A,B):\njulia> hashfn = MinHash();\n\njulia> A = Set([\"a\", \"b\", \"c\"]);\n\njulia> B = Set([\"b\", \"c\", \"d\"]);\n\njulia> collision_probability(hashfn, A, B) ==\n       collision_probability(hashfn, jaccard(A,B)) ==\n       jaccard(A,B)\ntrue\nWe often want to compute the probability that not just one hash collides, but that multiple hashes collide simultaneously. You can calculate this using the n_hashes keyword argument. If left unspecified, then collision_probability will use n_hashes(hashfn) hash functions to compute the probability.\njulia> hashfn = MinHash(5);\n\njulia> A = Set([\"a\", \"b\", \"c\"]);\n\njulia> B = Set([\"b\", \"c\", \"d\"]);\n\njulia> collision_probability(hashfn, A, B) ==\n       collision_probability(hashfn, A, B; n_hashes=5) ==\n       collision_probability(hashfn, A, B; n_hashes=1)^5\ntrue\n\njulia> sim = jaccard(A,B);\n\njulia> collision_probability(hashfn, sim) ==\n       collision_probability(hashfn, sim; n_hashes=5) ==\n       collision_probability(hashfn, sim; n_hashes=1)^5\ntrue","category":"page"},{"location":"similarities/cosine/#Cosine-similarity-1","page":"Cosine similarity","title":"Cosine similarity","text":"","category":"section"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"warning: Under construction\nThis section is currently being developed. If you're interested in helping write this section, feel free to open a pull request; otherwise, please check back later.","category":"page"},{"location":"similarities/cosine/#Definition-1","page":"Cosine similarity","title":"Definition","text":"","category":"section"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"Cosine similarity, roughly speaking, measures the angle between a pair of inputs. Two inputs are very similar if the angle between them is low, and their similarity drops as the angle between them increases.","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"Concretely, cosine similarity is computed as","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"textcossim(xy) = fracleftlangle xyrightranglexcdoty = leftlanglefracxxfracyyrightrangle","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"where leftlanglecdotcdotrightrangle is an inner product (e.g., dot product) and cdot is the norm derived from that inner product. textcossim(xy) goes from -1 to 1, where -1 corresponds to low similarity and 1 corresponds to high similarity. To calculate cosine similarity, you can use the cossim function exported from the LSH module:","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"julia> using LSHFunctions, LinearAlgebra\n\njulia> x = [5, 3, -1, 1];  # norm(x) == 6\n\njulia> y = [2, -2, -2, 2]; # norm(y) == 4\n\njulia> cossim(x,y) == dot(x,y) / (norm(x)*norm(y))\ntrue\n\njulia> cossim(x,y) == (5*2 + 3*(-2) + (-1)*(-2) + 1*2) / (6*4)\ntrue","category":"page"},{"location":"similarities/cosine/#SimHash-1","page":"Cosine similarity","title":"SimHash","text":"","category":"section"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"SimHash[1][2] is a family of LSH functions for hashing with respect to cosine similarity. You can generate a new hash function from this family by calling SimHash:","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"julia> hashfn = SimHash();\n\njulia> n_hashes(hashfn)\n1\n\njulia> hashfn = SimHash(40);\n\njulia> n_hashes(hashfn)\n40","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"Once constructed, you can start hashing vectors by calling hashfn(x):","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"hashfn = SimHash(100)\n\n# x and y have high cosine similarity since they point in the same direction\n# x and z have low cosine similarity since they point in opposite directions\nx = randn(128)\ny = 2x\nz = -x\n\nhx, hy, hz = hashfn(x), hashfn(y), hashfn(z)\n\n# Among the 100 hash functions that we generated, we expect more hash\n# collisions between x and y than between x and z\nsum(hx .== hy) > sum(hx .== hz)","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"Note that SimHash is a one-bit hash function. As a result, hashfn(x) returns a BitArray:","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"julia> hashfn = SimHash();\n\njulia> n_hashes(hashfn)\n1\n\njulia> hashes = hashfn(randn(4));\n\njulia> typeof(hashes)\nBitArray{1}\n\njulia> length(hashes)\n1","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"Since a single-bit hash doesn't do much to reduce the cost of similarity search, you usually want to generate multiple hash functions at once. For instance, in the snippet below we sample 10 hash functions, so that hashfn(x) is a length-10 BitArray:","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"julia> hashfn = SimHash(10);\n\njulia> n_hashes(hashfn)\n10\n\njulia> hashes = hashfn(randn(4));\n\njulia> length(hashes)\n10","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"The probability of a hash collision (for a single hash) is","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"Prh(x) = h(y) = 1 - fracthetapi","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"where theta = textarccos(textcossim(xy)) is the angle between x and y. This collision probability is shown in the plot below.","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"using PyPlot, LSHFunctions\nfig = figure()\nhashfn = SimHash()\nx = range(-1, 1; length=1024)\ny = [LSHFunctions.single_hash_collision_probability(hashfn, xii) for xii in x]\n\nplot(x, y)\ntitle(\"Probability of hash collision for SimHash\")\nxlabel(raw\"$cossim(x,y)$\")\nylabel(raw\"$Pr[h(x) = h(y)]$\")\n\nsavefig(\"simhash_collision_probability.svg\")","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"(Image: Probability of collision for SimHash)","category":"page"},{"location":"similarities/cosine/#Footnotes-1","page":"Cosine similarity","title":"Footnotes","text":"","category":"section"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"[1]: Moses S. Charikar. Similarity estimation techniques from rounding algorithms. In Proceedings of the Thiry-Fourth Annual ACM Symposium on Theory of Computing, STOC '02, page 380–388, New York, NY, USA, 2002. Association for Computing Machinery. 10.1145/509907.509965.","category":"page"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"[2]: SimHash API reference","category":"page"},{"location":"similarities/inner_prod/#Inner-product-similarity-1","page":"Inner product similarity","title":"Inner product similarity","text":"","category":"section"},{"location":"similarities/inner_prod/#","page":"Inner product similarity","title":"Inner product similarity","text":"warning: Under construction\nThis section is currently being developed. If you're interested in helping write this section, feel free to open a pull request; otherwise, please check back later.","category":"page"},{"location":"full_api/#API-reference-1","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"full_api/#LSHFunction-API-1","page":"API reference","title":"LSHFunction API","text":"","category":"section"},{"location":"full_api/#","page":"API reference","title":"API reference","text":"LSHFunction\nlsh_family\nhashtype\nn_hashes\nsimilarity\ncollision_probability\nindex_hash\nquery_hash\nSymmetricLSHFunction\nAsymmetricLSHFunction","category":"page"},{"location":"full_api/#LSHFunctions.LSHFunction","page":"API reference","title":"LSHFunctions.LSHFunction","text":"LSHFunction(similarity, args...; kws...)\n\nConstruct the default LSHFunction subtype that corresponds to the similarity function similarity.\n\nArguments\n\nsimilarity: the similarity function you want to use. Can be any of the following:\ncossim\ninner_prod\njaccard\nℓ1\nℓ2\nargs...: arguments to pass on to the default LSHFunction constructor corresponding to similarity.\nkws...: keyword parameters to pass on to the default LSHFunction constructor corresponding to similarity.\n\nReturns\n\nReturns a subtype of LSH.LSHFunction that hashes the similarity function similarity.\n\nExamples\n\nIn the snippet below, we construct LSHFunctions.SimHash (the default hash function corresponding to cosine similarity) using LSHFunction():\n\njulia> hashfn = LSHFunction(cossim);\n\njulia> typeof(hashfn) <: LSHFunctions.SimHash <: LSHFunction\ntrue\n\nWe can provide arguments and keyword parameters corresponding to the hash function that we construct:\n\njulia> hashfn = LSHFunction(inner_prod, 100; dtype=Float64, maxnorm=10);\n\njulia> n_hashes(hashfn) == 100 &&\n       typeof(hashfn) <: SignALSH{Float64} &&\n       hashfn.maxnorm == 10\ntrue\n\nSee also: lsh_family\n\n\n\n","category":"type"},{"location":"full_api/#LSHFunctions.lsh_family","page":"API reference","title":"LSHFunctions.lsh_family","text":"lsh_family(similarity)\n\nReturn the default constructor or LSHFunction subtype used to construct a hash function for the similarity function similarity.\n\nThe main use of lsh_family is to make it easier to find the documentation for the hash function that's constructed when you call LSHFunction. For instance, if you want to know more about the arguments and keyword parameters that can be given to LSHFunction(inner_prod), you can run\n\njulia> lsh_family(inner_prod)\nSignALSH\n\nhelp?> SignALSH\n\nExamples\n\njulia> lsh_family(cossim)\nSimHash\n\njulia> lsh_family(ℓ1)\nL1Hash\n\nSee also: LSHFunction\n\n\n\n\n\n","category":"function"},{"location":"full_api/#LSHFunctions.hashtype","page":"API reference","title":"LSHFunctions.hashtype","text":"hashtype(hashfn::LSHFunction)\n\nReturns the type of hash generated by a hash function.\n\nExamples\n\njulia> hashfn = LSHFunction(cossim);\n\njulia> hashtype(hashfn)\nBool\n\njulia> hashfn = LSHFunction(ℓ1);\n\njulia> hashtype(hashfn)\nInt32\n\n\n\n\n\n","category":"function"},{"location":"full_api/#LSHFunctions.n_hashes","page":"API reference","title":"LSHFunctions.n_hashes","text":"n_hashes(hashfn::LSHFunction)\n\nReturn the number of hashes computed by hashfn.\n\nExamples\n\njulia> hashfn = SimHash();\n\njulia> n_hashes(hashfn)\n1\n\njulia> hashfn = SimHash(12);\n\njulia> n_hashes(hashfn)\n12\n\njulia> hashes = hashfn(rand(25));\n\njulia> length(hashes)\n12\n\n\n\n\n\n","category":"function"},{"location":"full_api/#LSHFunctions.similarity","page":"API reference","title":"LSHFunctions.similarity","text":"similarity(hashfn::LSHFunction)\n\nReturns the similarity function that hashfn hashes on.\n\nArguments\n\nhashfn::AbstractLSHFunction: the hash function whose similarity we would like to retrieve.\n\nExamples\n\njulia> hashfn = LSHFunction(cossim);\n\njulia> similarity(hashfn) == cossim\ntrue\n\njulia> hashfn = LSHFunction(ℓ1);\n\njulia> similarity(hashfn) == ℓ1\ntrue\n\n\n\n\n\n","category":"function"},{"location":"full_api/#LSHFunctions.collision_probability","page":"API reference","title":"LSHFunctions.collision_probability","text":"collision_probability(hashfn::H, sim;\n                      n_hashes::Union{Symbol,Integer}=:auto) where {H <: LSHFunction}\n\nCompute the probability of hash collision between two inputs with similarity sim for an LSHFunction of type H. This function returns the probability that n_hashes hashes simultaneously collide.\n\nArguments\n\nhashfn::LSHFunction: the LSHFunction for which we want to compute the probability of collision.\nsim: a similarity (or vector of similarities), computed using the similarity function returned by similarity(hashfn).\n\nKeyword arguments\n\nn_hashes::Union{Symbol,Integer} (default: :auto): the number of hash functions to use to compute the probability of collision. If the probability that a single hash collides is p, then the probability that n_hashes hashes simultaneously collide is\np^textn_hashes\nAs a result, collision_probability(hashfn, sim; n_hashes=N) is the same as collision_probability(hashfn, sim; n_hashes=1).^N. If n_hashes = :auto then this function will select the number of hashes to be n_hashes(hashfn) (using the n_hashes function from the LSHFunction API).\n\nExamples\n\nThe probability that a single MinHash hash function causes a hash collision between inputs A and B is equal to jaccard(A,B):\n\njulia> hashfn = MinHash();\n\njulia> A = Set([\"a\", \"b\", \"c\"]);\n\njulia> B = Set([\"b\", \"c\", \"d\"]);\n\njulia> jaccard(A,B)\n0.5\n\njulia> collision_probability(hashfn, jaccard(A,B); n_hashes=1)\n0.5\n\nIf our MinHash struct keeps track of N hash functions simultaneously, then the probability of collision is jaccard(A,B)^N:\n\njulia> hashfn = MinHash(10);\n\njulia> A = Set([\"a\", \"b\", \"c\"]);\n\njulia> B = Set([\"b\", \"c\", \"d\"]);\n\njulia> collision_probability(hashfn, jaccard(A,B)) ==\n       collision_probability(hashfn, jaccard(A,B); n_hashes=10) ==\n       collision_probability(hashfn, jaccard(A,B); n_hashes=1)^10\ntrue\n\nSee also: n_hashes, similarity\n\n\n\n\n\ncollision_probability(hashfn::LSHFunction, x, y;\n                      n_hashes::Union{Symbol,Integer} = :auto)\n\nComputes the probability of a hash collision between two inputs x and y for a given hash function hashfn. This is the same as calling\n\ncollision_probability(hashfn, similarity(hashfn)(x,y); n_hashes=n_hashes)\n\nExamples\n\nThe following snippet computes the probability of collision between two sets A and B for a single MinHash. For MinHash, this probability is just equal to the Jaccard similarity between A and B.\n\njulia> hashfn = MinHash();\n\njulia> A = Set([\"a\", \"b\", \"c\"]);\n\njulia> B = Set([\"a\", \"b\", \"c\"]);\n\njulia> similarity(hashfn) == jaccard\ntrue\n\njulia> collision_probability(hashfn, A, B) ==\n       collision_probability(hashfn, jaccard(A,B)) ==\n       jaccard(A,B)\ntrue\n\nWe can use the n_hashes argument to specify the probability that n_hashes MinHash hash functions simultaneously collide. If left unspecified, then we'll simply use n_hashes(hashfn) as the number of hash functions:\n\njulia> hashfn = MinHash(10);\n\njulia> A = Set([\"a\", \"b\", \"c\"]);\n\njulia> B = Set([\"a\", \"b\", \"c\"]);\n\njulia> collision_probability(hashfn, A, B) ==\n       collision_probability(hashfn, A, B; n_hashes=10) ==\n       collision_probability(hashfn, A, B; n_hashes=1)^10\ntrue\n\n\n\n\n\n","category":"function"},{"location":"full_api/#LSHFunctions.index_hash","page":"API reference","title":"LSHFunctions.index_hash","text":"index_hash(hashfn::AsymmetricLSHFunction, x)\n\nComputes the indexing hash (the hash used to insert items into the hash table) for an AsymmetricLSHFunction with input x.\n\nSee also: query_hash, AsymmetricLSHFunction\n\n\n\n\n\n","category":"function"},{"location":"full_api/#LSHFunctions.query_hash","page":"API reference","title":"LSHFunctions.query_hash","text":"query_hash(hashfn::AsymmetricLSHFunction, x)\n\nComputes the querying hash (the hash used to query for items in the hash table) for an AsymmetricLSHFunction with input x.\n\nSee also: index_hash, AsymmetricLSHFunction\n\n\n\n\n\n","category":"function"},{"location":"full_api/#LSHFunctions.SymmetricLSHFunction","page":"API reference","title":"LSHFunctions.SymmetricLSHFunction","text":"abstract type SymmetricLSHFunction <: LSHFunction end\n\nA symmetric locality-sensitive hashing function. A SymmetricLSHFunction uses the same hash function to insert items into a hash table as well as query the table for collisions. If hashfn is a SymmetricLSHFunction, you can compute the hash for an input x as hashfn(x).\n\nSee also: AsymmetricLSHFunction\n\n\n\n\n\n","category":"type"},{"location":"full_api/#LSHFunctions.AsymmetricLSHFunction","page":"API reference","title":"LSHFunctions.AsymmetricLSHFunction","text":"abstract type AsymmetricLSHFunction <: LSHFunction end\n\nAn asymmetric locality-sensitive hashing function. An AsymmetricLSHFunction uses one hash function to insert items into a hash table, and a different hash function to query the table for collisions. If hashfn is an AsymmetricLSHFunction, you can compute the indexing hash for an input x with index_hash(hashfn,x), and the querying hash with query_hash(hashfn,x).\n\nSee also: SymmetricLSHFunction\n\n\n\n\n\n","category":"type"},{"location":"full_api/#Hash-functions-1","page":"API reference","title":"Hash functions","text":"","category":"section"},{"location":"full_api/#","page":"API reference","title":"API reference","text":"SimHash\nMinHash\nL1Hash\nL2Hash\nSignALSH\nMIPSHash","category":"page"},{"location":"full_api/#LSHFunctions.SimHash","page":"API reference","title":"LSHFunctions.SimHash","text":"SimHash(n_hashes::Integer = 1;\n        dtype::DataType = Float32,\n        resize_pow2::Bool = false)\n\nCreates a locality-sensitive hash function for cosine similarity.\n\nArguments\n\nn_hashes::Integer (default: 1): the number of hash functions to generate.\n\nKeyword parameters\n\ndtype::DataType (default: Float32): the data type to use in the LSHFunctions.SimHash internals. For performance reasons you should pick dtype to match the type of the data you're hashing.\nresize_pow2::Bool (default: false): affects the way in which the returned LSHFunctions.SimHash resizes to hash inputs of different sizes. If you think you'll be hashing inputs of many different sizes, it's more efficient to set resize_pow2 = true.\n\nExamples\n\nConstruct a hash function by calling SimHash with the number of hash functions you want to generate:\n\njulia> hashfn = SimHash(24);\n\njulia> n_hashes(hashfn) == 24 &&\n       similarity(hashfn) == cossim\ntrue\n\nYou can then call hashfn(x) in order to compute hashes:\n\njulia> hashfn = SimHash(32);\n\njulia> x = randn(30);\n\njulia> hashes = hashfn(x);\n\n\nReferences\n\nMoses S. Charikar. Similarity estimation techniques from rounding algorithms. In Proceedings of the Thiry-Fourth Annual ACM Symposium on Theory of Computing, STOC '02, page 380–388, New York, NY, USA, 2002. Association for Computing Machinery. 10.1145/509907.509965.\n\nSee also: cossim\n\n\n\n\n\n","category":"type"},{"location":"full_api/#LSHFunctions.MinHash","page":"API reference","title":"LSHFunctions.MinHash","text":"MinHash(n_hashes::Integer = 1;\n        dtype::DataType = Any,\n        symbols::Union{Vector,Set} = Set())\n\nConstruct a locality-sensitive hash function for Jaccard similarity.\n\nArguments\n\nn_hashes::Integer (default: 1): the number of hash functions to generate.\n\nKeyword parameters\n\ndtype::DataType (default: Any): the type of symbols in the sets you're hashing. This is overriden by the data type contained in symbols when symbols is non-empty.\nsymbols::Union{Vector,Set}: a Vector or Set containing all of the possible elements (\"symbols\") of the sets that you will be hashing. If left empty, MinHash will instead expand its dictionary when it sees new symbols (at small additional computational expense).\n\nExamples\n\nConstruct a hash function to hash sets whose elements are integers between 1 and 50:\n\njulia> hashfn = MinHash(40; symbols = Set(1:50));\n\njulia> n_hashes(hashfn) == 40 && similarity(hashfn) == jaccard\ntrue\n\njulia> hashfn(Set([38, 14, 29, 48, 11]));\n\njulia> hashfn([1, 1, 2, 3, 4]); # You can also hash Vectors\n\njulia> hashfn(Set([100]))\nERROR: Symbol 100 not found\n\nIf you aren't sure ahead of time exactly what kinds of elements will be in the sets you're hashing, you can opt not to specify symbols, in which case MinHash will lazily update its hash functions as it encounters new symbols:\n\njulia> hashfn = MinHash();\n\njulia> hashfn(Set([1, 2, 3]));\n\njulia> hashfn(Set([\"a\", \"b\", \"c\"]));\n\n\nIf you don't know what elements you'll encounter, but you know that they'll all be of a specific data type, you can specify the dtype argument for increased efficiency:\n\njulia> hashfn = MinHash(10; dtype = String);\n\njulia> hashfn(Set([\"a\", \"b\", \"c\"]));\n\n\nReferences\n\nBroder, A. On the resemblance and containment of documents. Compression and Complexity of Sequences: Proceedings, Positano, Amalfitan Coast, Salerno, Italy, June 11-13, 1997. doi:10.1109/SEQUEN.1997.666900.\n\nSee also: jaccard\n\n\n\n\n\n","category":"type"},{"location":"full_api/#LSHFunctions.L1Hash","page":"API reference","title":"LSHFunctions.L1Hash","text":"L1Hash(\n    n_hashes::Integer = 1;\n    dtype::DataType = Float32,\n    r::Real = 1.0,\n    resize_pow2::Bool = false\n)\n\nConstructs a locality-sensitive hash for ell^1 distance (x - y_1), defined as\n\nx - y_1 = sum_i x_i - y_i\n\nArguments\n\nn_hashes::Integer (default: 1): the number of hash functions to generate.\n\nKeyword parameters\n\ndtype::DataType (default: Float32): the data type to use in the LSHFunctions.L1Hash internals. For performance reasons you should pick dtype to match the type of the data you're hashing.\nr::Real (default: 1.0): a positive coefficient whose magnitude influences the collision rate. Larger values of r will increase the collision rate, even for distant points. See references for more information.\nresize_pow2::Bool (default: false): affects the way in which the returned LSHFunctions.L1Hash resizes to hash inputs of different sizes. If you think you'll be hashing inputs of many different sizes, it's more efficient to set resize_pow2 = true.\n\nExamples\n\nConstruct an L1Hash with the number of hash functions you want to generate:\n\njulia> hashfn = L1Hash(128);\n\njulia> hashfn.power == 1 &&\n       n_hashes(hashfn) == 128 &&\n       similarity(hashfn) == ℓ1\ntrue\n\nAfter creating a hash function, you can compute hashes with hashfn(x):\n\njulia> hashfn = L1Hash(20);\n\njulia> x = rand(4);\n\njulia> hashes = hashfn(x);\n\n\nReferences\n\nDatar, Mayur & Indyk, Piotr & Immorlica, Nicole & Mirrokni, Vahab. (2004). Locality-sensitive hashing scheme based on p-stable distributions. Proceedings of the Annual Symposium on Computational Geometry. 10.1145/997817.997857.\n\nSee also: ℓ1\n\n\n\n\n\n","category":"type"},{"location":"full_api/#LSHFunctions.L2Hash","page":"API reference","title":"LSHFunctions.L2Hash","text":"L2Hash(\n    n_hashes::Integer = 1;\n    dtype::DataType = Float32,\n    r::Real = 1.0,\n    resize_pow2::Bool = false\n)\n\nConstructs a locality-sensitive hash for ell^2 distance (x - y_2), defined as\n\nx - y_2 = left(sum_i x_i - y_i^2right)^12\n\nArguments\n\nn_hashes::Integer (default: 1): the number of hash functions to generate.\n\nKeyword parameters\n\ndtype::DataType (default: Float32): the data type to use in the LSHFunctions.L2Hash internals. For performance reasons you should pick dtype to match the type of the data you're hashing.\nr::Real (default: 1.0): a positive coefficient whose magnitude influences the collision rate. Larger values of r will increase the collision rate, even for distant points. See references for more information.\nresize_pow2::Bool (default: false): affects the way in which the returned LSHFunctions.L2Hash resizes to hash inputs of different sizes. If you think you'll be hashing inputs of many different sizes, it's more efficient to set resize_pow2 = true.\n\nExamples\n\nConstruct an L2Hash with the number of hash functions you want to generate:\n\njulia> hashfn = L2Hash(128);\n\njulia> hashfn.power == 2 &&\n       n_hashes(hashfn) == 128 &&\n       similarity(hashfn) == ℓ2\ntrue\n\nAfter creating a hash function, you can compute hashes with hashfn(x):\n\njulia> hashfn = L2Hash(20);\n\njulia> x = rand(4);\n\njulia> hashes = hashfn(x);\n\n\nReferences\n\nDatar, Mayur & Indyk, Piotr & Immorlica, Nicole & Mirrokni, Vahab. (2004). Locality-sensitive hashing scheme based on p-stable distributions. Proceedings of the Annual Symposium on Computational Geometry. 10.1145/997817.997857.\n\nSee also: ℓ2\n\n\n\n\n\n","category":"type"},{"location":"full_api/#LSHFunctions.SignALSH","page":"API reference","title":"LSHFunctions.SignALSH","text":"SignALSH(n_hashes::Integer = 1,\n         dtype::DataType = Float32,\n         maxnorm::Union{Nothing,Real} = nothing,\n         m::Integer = 3,\n         resize_pow2::Bool = false)\n\nCreate a SignALSH hash function for hashing on inner product similarity.\n\nArguments\n\nn_hashes::Integer (default: 1): the number of hash functions to generate.\n\nKeyword parameters\n\ndtype::DataType (default: Float32): the data type to use in the LSHFunctions.SignALSH internals. For performance reasons you should pick dtype to match the type of the data you're hashing.\nmaxnorm::Union{Nothing,Real} (default: nothing): an upper bound on the ell^2-norm of the data points.\n\nwarning: Warning: maxnorm must be set\nThe maxnorm keyword parameter must be explicitly specified. If it is left unspecified (or set to nothing), SignALSH() will raise an error.\n\nm::Integer (default: 3): parameter m that affects the probability of a hash collision.\nresize_pow2::Bool (default: false): affects the way in which the returned LSHFunctions.SignALSH resizes to hash inputs of different sizes. If you think you'll be hashing inputs of many different sizes, it's more efficient to set resize_pow2 = true.\n\nExamples\n\nSignALSH is an AsymmetricLSHFunction, and hence hashes must be computed using index_hash and query_hash.\n\njulia> hashfn = SignALSH(12; maxnorm=10);\n\njulia> x = rand(4);\n\njulia> ih = index_hash(hashfn, x); qh = query_hash(hashfn, x);\n\njulia> length(ih) == length(qh) == 12\ntrue\n\njulia> typeof(ih) == typeof(qh) == BitArray{1}\ntrue\n\nYou need to explicitly specify the maxnorm keyword parameter when constructing SignALSH, otherwise you will get an error.\n\njulia> hashfn = SignALSH(12)\nERROR: maxnorm must be specified for SignALSH\n\nYou'll also get an error if you try to hash a vector that has norm greater than the maxnorm that you specified.\n\njulia> hashfn = SignALSH(; maxnorm=1);\n\njulia> index_hash(hashfn, ones(4))\nERROR: norm 2.0 exceeds maxnorm (1.0)\n\nReferences\n\nAnshumali Shrivastava and Ping Li. Improved Asymmetric Locality Sensitive Hashing (ALSH) for Maximum Inner Product Search (MIPS). In Proceedings of the Thirty-First Conference on Uncertainty in Artificial Intelligence, UAI'15, page 812–821, Arlington, Virginia, USA, 2015. AUAI Press. 10.5555/3020847.3020931. arXiv:1405.5869\n\nSee also: inner_prod, ℓ2_norm\n\n\n\n\n\n","category":"type"},{"location":"full_api/#LSHFunctions.MIPSHash","page":"API reference","title":"LSHFunctions.MIPSHash","text":"MIPSHash(n_hashes::Integer = 1;\n         dtype::Datatype = Float32,\n         maxnorm::Union{Nothing,Real} = nothing,\n         scale::Real = 1,\n         m::Integer = 3,\n         resize_pow2::Bool = false)\n\nCreate a MIPSHash hash function for hashing on inner product similarity.\n\nArguments\n\nn_hashes::Integer (default: 1): the number of hash functions to generate.\n\nKeyword parameters\n\ndtype::DataType (default: Float32): the data type to use in the LSHFunctions.MIPSHash internals. For performance reasons you should pick dtype to match the type of the data you're hashing.\nmaxnorm::Union{Nothing,Real} (default: nothing): an upper bound on the ell^2-norm of the data points.\n\nwarning: Warning: maxnorm must be explicitly set\nThe maxnorm keyword parameter must be explicitly specified. If it is left unspecified (or set to nothing), MIPSHash() will raise an error.\n\nscale::Real (default: 1): parameter that affects the probability of a hash collision. Large values of scale increases hash collision probability (even for inputs with low inner product similarity); small values of scale will decrease hash collision probability.\n\nExamples\n\nMIPSHash is an AsymmetricLSHFunction, and hence hashes must be computed using index_hash and query_hash.\n\njulia> hashfn = MIPSHash(5; maxnorm=10);\n\njulia> x = rand(4);\n\njulia> ih = index_hash(hashfn, x); qh = query_hash(hashfn, x);\n\njulia> length(ih) == length(qh) == 5\ntrue\n\njulia> typeof(ih) == typeof(qh) == Vector{Int32}\ntrue\n\nYou need to explicitly specify the maxnorm keyword parameter when constructing MIPSHash, otherwise you will get an error.\n\njulia> hashfn = MIPSHash(5)\nERROR: maxnorm must be specified for MIPSHash\n\nYou'll also get an error if you try to hash a vector that has norm greater than the maxnorm that you specified.\n\njulia> hashfn = MIPSHash(; maxnorm=1);\n\njulia> index_hash(hashfn, ones(4))\nERROR: norm 2.0 exceeds maxnorm (1.0)\n\nReferences\n\nAnshumali Shrivastava and Ping Li. Asymmetric LSH (ALSH) for Sublinear Time Maximum Inner Product Search (MIPS). Proceedings of the 27th International Conference on Neural Information Processing Systems - Volume 2, NIPS'14, page 2321–2329, Cambridge, MA, USA, 2014. MIT Press. 10.5555/2969033.2969086. arXiv:1410.5410\n\nSee also: inner_prod, ℓ2_norm\n\n\n\n\n\n","category":"type"},{"location":"full_api/#Similarity-functions-1","page":"API reference","title":"Similarity functions","text":"","category":"section"},{"location":"full_api/#","page":"API reference","title":"API reference","text":"Modules = [LSHFunctions]\nPrivate = false\nPages = [\"similarities.jl\"]","category":"page"},{"location":"full_api/#LSHFunctions.L1-Tuple{Any,Any,LSHFunctions.RealInterval}","page":"API reference","title":"LSHFunctions.L1","text":"Lp(x::AbstractVector, y::AbstractVector, p::Real=2)\nL1(x::AbstractVector, y::AbstractVector)\nL2(x::AbstractVector, y::AbstractVector)\n\nComputes the ℓ^p distance between a pair of vectors x and y. Identical to ℓp(x,y,p), ℓ1(x,y), and ℓ2(x,y), respectively.\n\nSee also: ℓp\n\n\n\n\n\nLp(f, g, interval::LSHFunctions.RealInterval, p)\nL1(f, g, interval::LSHFunctions.RealInterval)\nL2(f, g, interval::LSHFunctions.RealInterval)\n\nComputes the L^p distance between two functions, given by\n\nL^p(fg) coloneqq f - g_p = left(int_a^b leftf(x) - g(x)right^p hspace015cm dxright)^1p\n\nExamples\n\nBelow we compute the L^1, L^2, and L^3 distances between f(x) = x^2 + 1 and g(x) = 2x over the interval 01. The distances are computed by evaluating the integral\n\nleft(int_0^1 leftf(x) - g(x)right^p hspace015cmdxright)^1p = left(int_0^1 leftx^2 - 2x + 1right^p hspace015cmdxright)^1p = left(int_0^1 (x - 1)^2p hspace015cmdxright)^1p\n\nfor p = 1, p = 2, and p = 3.\n\njulia> f(x) = x^2 + 1; g(x) = 2x;\n\njulia> interval = @interval(0 ≤ x ≤ 1);\n\njulia> Lp(f, g, interval, 1) ≈ L1(f, g, interval) ≈ 3^(-1)\ntrue\n\njulia> Lp(f, g, interval, 2) ≈ L2(f, g, interval) ≈ 5^(-1/2)\ntrue\n\njulia> Lp(f, g, interval, 3) ≈ 7^(-1/3)\ntrue\n\nSee also: Lp_norm, ℓp\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.L1-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1} where T}} where T","page":"API reference","title":"LSHFunctions.L1","text":"Lp(x::AbstractVector, y::AbstractVector, p::Real=2)\nL1(x::AbstractVector, y::AbstractVector)\nL2(x::AbstractVector, y::AbstractVector)\n\nComputes the ℓ^p distance between a pair of vectors x and y. Identical to ℓp(x,y,p), ℓ1(x,y), and ℓ2(x,y), respectively.\n\nSee also: ℓp\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.L1_norm-Tuple{AbstractArray{T,1} where T}","page":"API reference","title":"LSHFunctions.L1_norm","text":"Lp_norm(x::AbstractVector, p::Real = 2)\nL1_norm(x::AbstractVector)\nL2_norm(x::AbstractVector)\n\nCompute the ell^p norm of a vector x. Identical to ℓp_norm(x,p), ℓ1_norm(x), and ℓ2_norm(x), respectively.\n\nSee also: ℓp_norm\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.L1_norm-Tuple{Any,LSHFunctions.RealInterval}","page":"API reference","title":"LSHFunctions.L1_norm","text":"Lp_norm(x::AbstractVector, p::Real = 2)\nL1_norm(x::AbstractVector)\nL2_norm(x::AbstractVector)\n\nCompute the ell^p norm of a vector x. Identical to ℓp_norm(x,p), ℓ1_norm(x), and ℓ2_norm(x), respectively.\n\nSee also: ℓp_norm\n\n\n\n\n\nLp_norm(f, interval::LSHFunctions.RealInterval, p::Real=2)\nL1_norm(f, interval::LSHFunctions.RealInterval)\nL2_norm(f, interval::LSHFunctions.RealInterval)\n\nComputes the L^p function-space norm of a function f, which is given by the equation\n\nf_p = left(int_a^b leftf(x)right^p hspace015cm dxright)^1p\n\nL1_norm(f, interval) is the same as Lp_norm(f, interval, 1), and L2_norm(f, interval) is the same as Lp_norm(f, interval, 2).\n\nExamples\n\njulia> f(x) = x;\n\njulia> interval = @interval(0 ≤ x ≤ 1);\n\njulia> Lp_norm(f, interval, 1) ≈ L1_norm(f, interval) ≈ 2^(-1/1)\ntrue\n\njulia> Lp_norm(f, interval, 2) ≈ L2_norm(f, interval) ≈ 3^(-1/2)\ntrue\n\njulia> Lp_norm(f, interval, 3) ≈ 4^(-1/3)\ntrue\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.L2-Tuple{Any,Any,LSHFunctions.RealInterval}","page":"API reference","title":"LSHFunctions.L2","text":"Lp(x::AbstractVector, y::AbstractVector, p::Real=2)\nL1(x::AbstractVector, y::AbstractVector)\nL2(x::AbstractVector, y::AbstractVector)\n\nComputes the ℓ^p distance between a pair of vectors x and y. Identical to ℓp(x,y,p), ℓ1(x,y), and ℓ2(x,y), respectively.\n\nSee also: ℓp\n\n\n\n\n\nLp(f, g, interval::LSHFunctions.RealInterval, p)\nL1(f, g, interval::LSHFunctions.RealInterval)\nL2(f, g, interval::LSHFunctions.RealInterval)\n\nComputes the L^p distance between two functions, given by\n\nL^p(fg) coloneqq f - g_p = left(int_a^b leftf(x) - g(x)right^p hspace015cm dxright)^1p\n\nExamples\n\nBelow we compute the L^1, L^2, and L^3 distances between f(x) = x^2 + 1 and g(x) = 2x over the interval 01. The distances are computed by evaluating the integral\n\nleft(int_0^1 leftf(x) - g(x)right^p hspace015cmdxright)^1p = left(int_0^1 leftx^2 - 2x + 1right^p hspace015cmdxright)^1p = left(int_0^1 (x - 1)^2p hspace015cmdxright)^1p\n\nfor p = 1, p = 2, and p = 3.\n\njulia> f(x) = x^2 + 1; g(x) = 2x;\n\njulia> interval = @interval(0 ≤ x ≤ 1);\n\njulia> Lp(f, g, interval, 1) ≈ L1(f, g, interval) ≈ 3^(-1)\ntrue\n\njulia> Lp(f, g, interval, 2) ≈ L2(f, g, interval) ≈ 5^(-1/2)\ntrue\n\njulia> Lp(f, g, interval, 3) ≈ 7^(-1/3)\ntrue\n\nSee also: Lp_norm, ℓp\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.L2-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1} where T}} where T","page":"API reference","title":"LSHFunctions.L2","text":"Lp(x::AbstractVector, y::AbstractVector, p::Real=2)\nL1(x::AbstractVector, y::AbstractVector)\nL2(x::AbstractVector, y::AbstractVector)\n\nComputes the ℓ^p distance between a pair of vectors x and y. Identical to ℓp(x,y,p), ℓ1(x,y), and ℓ2(x,y), respectively.\n\nSee also: ℓp\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.L2_norm-Tuple{AbstractArray{T,1} where T}","page":"API reference","title":"LSHFunctions.L2_norm","text":"Lp_norm(x::AbstractVector, p::Real = 2)\nL1_norm(x::AbstractVector)\nL2_norm(x::AbstractVector)\n\nCompute the ell^p norm of a vector x. Identical to ℓp_norm(x,p), ℓ1_norm(x), and ℓ2_norm(x), respectively.\n\nSee also: ℓp_norm\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.L2_norm-Tuple{Any,LSHFunctions.RealInterval}","page":"API reference","title":"LSHFunctions.L2_norm","text":"Lp_norm(x::AbstractVector, p::Real = 2)\nL1_norm(x::AbstractVector)\nL2_norm(x::AbstractVector)\n\nCompute the ell^p norm of a vector x. Identical to ℓp_norm(x,p), ℓ1_norm(x), and ℓ2_norm(x), respectively.\n\nSee also: ℓp_norm\n\n\n\n\n\nLp_norm(f, interval::LSHFunctions.RealInterval, p::Real=2)\nL1_norm(f, interval::LSHFunctions.RealInterval)\nL2_norm(f, interval::LSHFunctions.RealInterval)\n\nComputes the L^p function-space norm of a function f, which is given by the equation\n\nf_p = left(int_a^b leftf(x)right^p hspace015cm dxright)^1p\n\nL1_norm(f, interval) is the same as Lp_norm(f, interval, 1), and L2_norm(f, interval) is the same as Lp_norm(f, interval, 2).\n\nExamples\n\njulia> f(x) = x;\n\njulia> interval = @interval(0 ≤ x ≤ 1);\n\njulia> Lp_norm(f, interval, 1) ≈ L1_norm(f, interval) ≈ 2^(-1/1)\ntrue\n\njulia> Lp_norm(f, interval, 2) ≈ L2_norm(f, interval) ≈ 3^(-1/2)\ntrue\n\njulia> Lp_norm(f, interval, 3) ≈ 4^(-1/3)\ntrue\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.Lp","page":"API reference","title":"LSHFunctions.Lp","text":"Lp(f, g, interval::LSHFunctions.RealInterval, p)\nL1(f, g, interval::LSHFunctions.RealInterval)\nL2(f, g, interval::LSHFunctions.RealInterval)\n\nComputes the L^p distance between two functions, given by\n\nL^p(fg) coloneqq f - g_p = left(int_a^b leftf(x) - g(x)right^p hspace015cm dxright)^1p\n\nExamples\n\nBelow we compute the L^1, L^2, and L^3 distances between f(x) = x^2 + 1 and g(x) = 2x over the interval 01. The distances are computed by evaluating the integral\n\nleft(int_0^1 leftf(x) - g(x)right^p hspace015cmdxright)^1p = left(int_0^1 leftx^2 - 2x + 1right^p hspace015cmdxright)^1p = left(int_0^1 (x - 1)^2p hspace015cmdxright)^1p\n\nfor p = 1, p = 2, and p = 3.\n\njulia> f(x) = x^2 + 1; g(x) = 2x;\n\njulia> interval = @interval(0 ≤ x ≤ 1);\n\njulia> Lp(f, g, interval, 1) ≈ L1(f, g, interval) ≈ 3^(-1)\ntrue\n\njulia> Lp(f, g, interval, 2) ≈ L2(f, g, interval) ≈ 5^(-1/2)\ntrue\n\njulia> Lp(f, g, interval, 3) ≈ 7^(-1/3)\ntrue\n\nSee also: Lp_norm, ℓp\n\n\n\n\n\n","category":"function"},{"location":"full_api/#LSHFunctions.Lp-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1} where T}, Tuple{AbstractArray{T,1},AbstractArray{T,1} where T,Real}} where T","page":"API reference","title":"LSHFunctions.Lp","text":"Lp(x::AbstractVector, y::AbstractVector, p::Real=2)\nL1(x::AbstractVector, y::AbstractVector)\nL2(x::AbstractVector, y::AbstractVector)\n\nComputes the ℓ^p distance between a pair of vectors x and y. Identical to ℓp(x,y,p), ℓ1(x,y), and ℓ2(x,y), respectively.\n\nSee also: ℓp\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.Lp_norm","page":"API reference","title":"LSHFunctions.Lp_norm","text":"Lp_norm(f, interval::LSHFunctions.RealInterval, p::Real=2)\nL1_norm(f, interval::LSHFunctions.RealInterval)\nL2_norm(f, interval::LSHFunctions.RealInterval)\n\nComputes the L^p function-space norm of a function f, which is given by the equation\n\nf_p = left(int_a^b leftf(x)right^p hspace015cm dxright)^1p\n\nL1_norm(f, interval) is the same as Lp_norm(f, interval, 1), and L2_norm(f, interval) is the same as Lp_norm(f, interval, 2).\n\nExamples\n\njulia> f(x) = x;\n\njulia> interval = @interval(0 ≤ x ≤ 1);\n\njulia> Lp_norm(f, interval, 1) ≈ L1_norm(f, interval) ≈ 2^(-1/1)\ntrue\n\njulia> Lp_norm(f, interval, 2) ≈ L2_norm(f, interval) ≈ 3^(-1/2)\ntrue\n\njulia> Lp_norm(f, interval, 3) ≈ 4^(-1/3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"full_api/#LSHFunctions.Lp_norm","page":"API reference","title":"LSHFunctions.Lp_norm","text":"Lp_norm(x::AbstractVector, p::Real = 2)\nL1_norm(x::AbstractVector)\nL2_norm(x::AbstractVector)\n\nCompute the ell^p norm of a vector x. Identical to ℓp_norm(x,p), ℓ1_norm(x), and ℓ2_norm(x), respectively.\n\nSee also: ℓp_norm\n\n\n\n\n\n","category":"function"},{"location":"full_api/#LSHFunctions.cossim-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"API reference","title":"LSHFunctions.cossim","text":"cossim(x,y)\n\nComputes the cosine similarity between two inputs x and y. Cosine similarity is defined as\n\ntextcossim(xy) = fracleftlangle xyrightranglexcdoty\n\nwhere leftlanglecdotcdotrightrangle is an inner product (e.g. dot product) and cdot is its derived norm. This is roughly interpreted as being related to the angle between the inputs x and y: when x and y have low angle between them, cossim(x,y) is high (close to 1). When x and y have large angle between them, cossim(x,y) is low (close to -1).\n\nArguments\n\nx and y: two inputs for which dot(x,y), norm(x), and norm(y) are defined.\n\nExamples\n\njulia> using LinearAlgebra: dot, norm;\n\njulia> x, y = rand(4), rand(4);\n\njulia> cossim(x,y) == dot(x,y) / (norm(x) * norm(y))\ntrue\n\njulia> z = rand(5);\n\njulia> cossim(x,z)\nERROR: DimensionMismatch(\"dot product arguments have lengths 4 and 5\")\n\nSee also: SimHash\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.inner_prod-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"API reference","title":"LSHFunctions.inner_prod","text":"inner_prod(x::AbstractVector, y::AbstractVector)\n\nComputes the ell^2 inner product (dot product)\n\nleftlangle x yrightrangle = sum_i x_iy_i\n\nExamples\n\njulia> using LinearAlgebra: dot;\n\njulia> x, y = randn(4), randn(4);\n\njulia> inner_prod(x,y) ≈ dot(x,y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.inner_prod-Tuple{Any,Any,LSHFunctions.RealInterval}","page":"API reference","title":"LSHFunctions.inner_prod","text":"inner_prod(f, g, interval::LSHFunctions.RealInterval)\n\nComputes the L^2 inner product\n\nleftlangle f grightrangle = int_a^b f(x)g(x) hspace015cm dx\n\nwhere the interval we're integrating over is specified by the interval argument.\n\nExamples\n\njulia> f(x) = cos(x); g(x) = sin(x);\n\njulia> inner_prod(f, g, @interval(0 ≤ x ≤ π/2)) ≈ 1/2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.jaccard-Tuple{Set,Set}","page":"API reference","title":"LSHFunctions.jaccard","text":"jaccard(A::Set, B::Set) :: Float64\n\nComputes the Jaccard similarity between sets A and B, which is defined as\n\ntextJaccard(AB) = fracleftA cap BrightleftA cup Bright\n\nArguments\n\nA::Set, B::Set: the two sets with which to compute Jaccard similarity.\n\nReturns\n\nFloat64: the Jaccard similarity between sets A and B, which is between 0 and 1.\n\nExamples\n\njulia> A, B = Set([1, 2, 3]), Set([2, 3, 4]);\n\njulia> jaccard(A,B)\n0.5\n\njulia> jaccard(A,B) == length(A ∩ B) / length(A ∪ B)\ntrue\n\nSee also: MinHash\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.wasserstein1_1d-Tuple{Any,Any}","page":"API reference","title":"LSHFunctions.wasserstein1_1d","text":"wasserstein_1d(f, g, p)\nwasserstein1_1d(f, g)\nwasserstein2_1d(f, g)\nemd(f, g)\n\nCompute the order-p Wasserstein distance between two probability distributions defined on the interval -11.\n\nwasserstein1_1d(f,g) == emd(f,g) == wasserstein_1d(f, g, 1)\nwasserstein2_1d(f,g) == wasserstein_1d(f, g, 2)\n\nArguments\n\nf and g: two probability distributions defined on -11.\np::Real: the order of Wasserstein distance to compute.\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.wasserstein2_1d-Tuple{Any,Any}","page":"API reference","title":"LSHFunctions.wasserstein2_1d","text":"wasserstein_1d(f, g, p)\nwasserstein1_1d(f, g)\nwasserstein2_1d(f, g)\nemd(f, g)\n\nCompute the order-p Wasserstein distance between two probability distributions defined on the interval -11.\n\nwasserstein1_1d(f,g) == emd(f,g) == wasserstein_1d(f, g, 1)\nwasserstein2_1d(f,g) == wasserstein_1d(f, g, 2)\n\nArguments\n\nf and g: two probability distributions defined on -11.\np::Real: the order of Wasserstein distance to compute.\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.wasserstein_1d-Tuple{Any,Any,Real}","page":"API reference","title":"LSHFunctions.wasserstein_1d","text":"wasserstein_1d(f, g, p)\nwasserstein1_1d(f, g)\nwasserstein2_1d(f, g)\nemd(f, g)\n\nCompute the order-p Wasserstein distance between two probability distributions defined on the interval -11.\n\nwasserstein1_1d(f,g) == emd(f,g) == wasserstein_1d(f, g, 1)\nwasserstein2_1d(f,g) == wasserstein_1d(f, g, 2)\n\nArguments\n\nf and g: two probability distributions defined on -11.\np::Real: the order of Wasserstein distance to compute.\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.ℓ1-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"API reference","title":"LSHFunctions.ℓ1","text":"ℓp(x::AbstractVector, y::AbstractVector, p::Real=2)\nℓ1(x::AbstractVector, y::AbstractVector)\nℓ2(x::AbstractVector, y::AbstractVector)\n\nComputes the ell^p distance between a pair of vectors, given by\n\nell^p(xy) coloneqq x - y_p = left(sum_i leftx_i - y_iright^pright)^1p\n\nℓ1(x,y) is the same as ℓp(x,y,1), and ℓ2(x,y) is the same as ℓp(x,y,2).\n\nExamples\n\njulia> x = [1, 2, 3];\n\njulia> y = [4, 5, 6];\n\njulia> ℓp(x,y,2) == (abs(1-4)^2 + abs(2-5)^2 + abs(3-6)^2)^(1/2)\ntrue\n\njulia> ℓp(x,y,3) == (abs(1-4)^3 + abs(2-5)^3 + abs(3-6)^3)^(1/3)\ntrue\n\nSee also: ℓp_norm, L1Hash, L2Hash\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.ℓ1_norm-Tuple{AbstractArray{T,1} where T}","page":"API reference","title":"LSHFunctions.ℓ1_norm","text":"ℓp_norm(x::AbstractVector, p::Real = 2)\nℓ1_norm(x::AbstractVector)\nℓ2_norm(x::AbstractVector)\n\nCompute the ell^p norm of a point x, defined as\n\nx_p = left(sum_i leftx_iright^pright)^1p\n\nExamples\n\njulia> x = randn(4);\n\njulia> ℓp_norm(x, 1) ≈ ℓ1_norm(x) ≈ (map(u -> abs(u)^1, x) |> sum)^(1/1)\ntrue\n\njulia> ℓp_norm(x, 2) ≈ ℓ2_norm(x) ≈ (map(u -> abs(u)^2, x) |> sum)^(1/2)\ntrue\n\njulia> ℓp_norm(x, 3) ≈ (map(u -> abs(u)^3, x) |> sum)^(1/3)\ntrue\n\nSee also: ℓp, Lp_norm\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.ℓ2-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"API reference","title":"LSHFunctions.ℓ2","text":"ℓp(x::AbstractVector, y::AbstractVector, p::Real=2)\nℓ1(x::AbstractVector, y::AbstractVector)\nℓ2(x::AbstractVector, y::AbstractVector)\n\nComputes the ell^p distance between a pair of vectors, given by\n\nell^p(xy) coloneqq x - y_p = left(sum_i leftx_i - y_iright^pright)^1p\n\nℓ1(x,y) is the same as ℓp(x,y,1), and ℓ2(x,y) is the same as ℓp(x,y,2).\n\nExamples\n\njulia> x = [1, 2, 3];\n\njulia> y = [4, 5, 6];\n\njulia> ℓp(x,y,2) == (abs(1-4)^2 + abs(2-5)^2 + abs(3-6)^2)^(1/2)\ntrue\n\njulia> ℓp(x,y,3) == (abs(1-4)^3 + abs(2-5)^3 + abs(3-6)^3)^(1/3)\ntrue\n\nSee also: ℓp_norm, L1Hash, L2Hash\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.ℓ2_norm-Tuple{AbstractArray{T,1} where T}","page":"API reference","title":"LSHFunctions.ℓ2_norm","text":"ℓp_norm(x::AbstractVector, p::Real = 2)\nℓ1_norm(x::AbstractVector)\nℓ2_norm(x::AbstractVector)\n\nCompute the ell^p norm of a point x, defined as\n\nx_p = left(sum_i leftx_iright^pright)^1p\n\nExamples\n\njulia> x = randn(4);\n\njulia> ℓp_norm(x, 1) ≈ ℓ1_norm(x) ≈ (map(u -> abs(u)^1, x) |> sum)^(1/1)\ntrue\n\njulia> ℓp_norm(x, 2) ≈ ℓ2_norm(x) ≈ (map(u -> abs(u)^2, x) |> sum)^(1/2)\ntrue\n\njulia> ℓp_norm(x, 3) ≈ (map(u -> abs(u)^3, x) |> sum)^(1/3)\ntrue\n\nSee also: ℓp, Lp_norm\n\n\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.ℓp","page":"API reference","title":"LSHFunctions.ℓp","text":"ℓp(x::AbstractVector, y::AbstractVector, p::Real=2)\nℓ1(x::AbstractVector, y::AbstractVector)\nℓ2(x::AbstractVector, y::AbstractVector)\n\nComputes the ell^p distance between a pair of vectors, given by\n\nell^p(xy) coloneqq x - y_p = left(sum_i leftx_i - y_iright^pright)^1p\n\nℓ1(x,y) is the same as ℓp(x,y,1), and ℓ2(x,y) is the same as ℓp(x,y,2).\n\nExamples\n\njulia> x = [1, 2, 3];\n\njulia> y = [4, 5, 6];\n\njulia> ℓp(x,y,2) == (abs(1-4)^2 + abs(2-5)^2 + abs(3-6)^2)^(1/2)\ntrue\n\njulia> ℓp(x,y,3) == (abs(1-4)^3 + abs(2-5)^3 + abs(3-6)^3)^(1/3)\ntrue\n\nSee also: ℓp_norm, L1Hash, L2Hash\n\n\n\n\n\n","category":"function"},{"location":"full_api/#LSHFunctions.ℓp_norm","page":"API reference","title":"LSHFunctions.ℓp_norm","text":"ℓp_norm(x::AbstractVector, p::Real = 2)\nℓ1_norm(x::AbstractVector)\nℓ2_norm(x::AbstractVector)\n\nCompute the ell^p norm of a point x, defined as\n\nx_p = left(sum_i leftx_iright^pright)^1p\n\nExamples\n\njulia> x = randn(4);\n\njulia> ℓp_norm(x, 1) ≈ ℓ1_norm(x) ≈ (map(u -> abs(u)^1, x) |> sum)^(1/1)\ntrue\n\njulia> ℓp_norm(x, 2) ≈ ℓ2_norm(x) ≈ (map(u -> abs(u)^2, x) |> sum)^(1/2)\ntrue\n\njulia> ℓp_norm(x, 3) ≈ (map(u -> abs(u)^3, x) |> sum)^(1/3)\ntrue\n\nSee also: ℓp, Lp_norm\n\n\n\n\n\n","category":"function"},{"location":"full_api/#Miscellaneous-1","page":"API reference","title":"Miscellaneous","text":"","category":"section"},{"location":"full_api/#","page":"API reference","title":"API reference","text":"@interval","category":"page"},{"location":"full_api/#LSHFunctions.@interval","page":"API reference","title":"LSHFunctions.@interval","text":"@interval(expr)\n\nConstruct a new LSHFunctions.RealInterval representing an interval on the real line from an expression such as\n\n0 ≤ x < 1\n\nThe returned expression constructs an LSHFunctions.RealInterval encoding the lower and upper bounds on the interval, as well as whether the ends are opened or closed.\n\nExamples\n\nYou can construct an interval using the following syntax:\n\njulia> interval = @interval(0 ≤ x < 1);\n\nThere are usually multiple ways of constructing the same interval. For instance, each of the expressions below are equivalent ways of constructing the interval [-1,1].\n\njulia> @interval(-1 ≤  x ≤  1) ==\n       @interval(-1 <= x <= 1) ==\n       @interval(-1 ≤  y ≤  1) ==\n       @interval( 1 ≥  x ≥ -1)\ntrue\n\nYou can even create intervals with Inf or -Inf at the endpoints, e.g. @interval(-Inf < x < Inf).\n\nThere are two primary operations you can run on an interval: testing for membership and intersection. You can test whether or not x is in an interval using x ∈ interval, as shown below.\n\njulia> interval = @interval(0 ≤ x < 1);\n\njulia> 0 ∈ interval && 1 ∉ interval\ntrue\n\njulia> 0 in interval    # This syntax also works\ntrue\n\nYou can also intersect two intervals using the ∩ operator (or by using intersect(interval_1, interval_2)).\n\njulia> @interval(0 ≤ x < 1) ∩ @interval(1/2 < x ≤ 1) == @interval(1/2 < x < 1)\ntrue\n\nSee also: RealInterval\n\n\n\n\n\n","category":"macro"},{"location":"full_api/#Private-interface-1","page":"API reference","title":"Private interface","text":"","category":"section"},{"location":"full_api/#","page":"API reference","title":"API reference","text":"Modules = [LSHFunctions]\nPublic = false","category":"page"},{"location":"full_api/#LSHFunctions.RealInterval","page":"API reference","title":"LSHFunctions.RealInterval","text":"struct RealInterval{T<:Real}\n\nEncodes an interval of the real line, such as [-1,1] or [0,Inf).\n\nFields\n\nlower::T: lower bound on the interval.\nupper::T: upper bound on the interval.\nclosed_below::Bool: whether or not the interval is closed below.\nclosed_above::Bool: whether or not the interval is closed above.\n\nExamples\n\nThe following snippet constructs RealInterval represeting the interval [0,1)\n\njulia> interval = LSHFunctions.RealInterval(0, 1, true, false);\n\nIt's generally easier to construct an interval using the @interval macro. Check out the documentation for @interval for more information.\n\nSee also: @interval\n\n\n\n\n\n","category":"type"},{"location":"full_api/#Base.isempty-Tuple{LSHFunctions.RealInterval}","page":"API reference","title":"Base.isempty","text":"isempty(interval::RealInterval)\n\nReturns true if interval is empty (i.e. there doesn't exist an x for which x ∈ interval is true), and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.width-Union{Tuple{LSHFunctions.RealInterval{T}}, Tuple{T}} where T","page":"API reference","title":"LSHFunctions.width","text":"width(interval::RealInterval)\n\nReturn the width of a RealInterval (i.e. the difference between its upper and lower bounds.\n\n\n\n\n\n","category":"method"},{"location":"full_api/#LSHFunctions.@register_similarity!-Tuple{Any,Any}","page":"API reference","title":"LSHFunctions.@register_similarity!","text":"register_similarity!(similarity, hashfn)\n\nRegister hashfn to the LSH module as the default locality-sensitive hash function to use for similarity function similarity. This makes it possible to construct a new hash function for similarity with LSHFunction(similarity, args...; kws...).\n\nArguments\n\nsimilarity: the similarity function to register.\nhashfn: the default locality-sensitive hash function that similarity should be associated with.\n\nExamples\n\nCreate a custom implementation of cosine similarity called my_cossim, and associate it with SimHash:\n\njulia> using LinearAlgebra: dot, norm\n\njulia> my_cossim(x,y) = dot(x,y) / (norm(x) * norm(y));\n\njulia> hashfn = LSHFunction(my_cossim);\nERROR: MethodError: no method matching LSHFunction(::typeof(my_cossim))\n\njulia> LSHFunctions.@register_similarity!(my_cossim, SimHash);\n\njulia> hashfn = LSHFunction(my_cossim);\n\njulia> isa(hashfn, SimHash)\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"faq/#FAQ-1","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/#Why-do-we-compute-multiple-hashes-for-every-input?-1","page":"FAQ","title":"Why do we compute multiple hashes for every input?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"In a traditional hash table data structure, you have a single hash function (e.g. MurmurHash) that you use to convert inputs into hashes, which you can then use to index into the table. With LSH, you randomly generate multiple hash functions from a single LSH family. To index into the hash table, you apply each of those hash functions to your input and concatenate your computed hashes together. The concatenated hashes form the key you use to index into the hash table.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"The reason for computing multiple hashes is that every LSH function provides (at most) only a few bits of additional information with which to partition the input space. For example, SimHash is a single-bit hash: that is, if you create hashfn = SimHash(), then hashfn(x) can only return either BitArray([0]) or BitArray([1]). If you're trying to use hashfn to speed up similarity search, then the hash you compute will – at best – reduce the number of points you have to search through by only 50% on average.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"In fact, the situation can be much more dire than that. If your data are highly structured, it is likely that each of your hashes will place data points into a tiny handful of buckets – even just one bucket. For instance, in the snippet below we have a dataset of 100 points that all have very high cosine similarity with one another. If we only create a single hash function when we call SimHash, then it's very likely that all of the data points will have the same hash.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"julia> hashfn = SimHash();\n\njulia> data = ones(10, 100);  # Each column is a data point\n\njulia> data[end,1:end] .= rand(100);  # Randomize the last dimension of each point\n\njulia> hashes = map(x -> hashfn(x), eachcol(data));\n\njulia> unique(hashes)\n1-element Array{BitArray{1},1}:\n [0]","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"The solution to this is to generate multiple hash functions, and combine each of the hashes we compute for an input into a single key. In the snippet below, we create 20 hash functions with SimHash. Each hash computed in map(x -> hashfn(x), eachcol(data)) is a length-20 BitArray.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"julia> hashfn = SimHash(20);\n\njulia> data = ones(10,100);  # Each column is a data point\n\njulia> data[end,1:end] .= rand(100);  # Randomize the last dimension of each point\n\njulia> hashes = map(x -> hashfn(x), eachcol(data));\n\njulia> unique(hashes) |> length\n3\n\njulia> for uh in unique(hashes)\n           println(sum(uh == h for h in hashes))\n       end\n72\n16\n12","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Our hash function has generated 3 unique 20-bit hashes, with 72 points sharing the first hash, 16 points sharing the second hash, and 12 points sharing the third hash. That's not a great split, but could still drastically reduce the size of the search space. For instance, the following benchmarks (on an Intel Core i7-8565U @ 1.80 GHz) suggest that the cost of computing 20-bit SimHash on 10-dimensional data is about 34 times the cost of computing cossim:","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"julia> using BenchmarkTools\n\njulia> @benchmark(hashfn(x), setup=(x=rand(10)))\nBenchmarkTools.Trial: \n  memory estimate:  4.66 KiB\n  allocs estimate:  6\n  --------------\n  minimum time:     612.231 ns (0.00% GC)\n  median time:      1.563 μs (0.00% GC)\n  mean time:        1.728 μs (17.60% GC)\n  maximum time:     24.123 μs (92.03% GC)\n  --------------\n  samples:          10000\n  evals/sample:     169\n\njulia> @benchmark(cossim(x,y), setup=(x=rand(10);y=rand(10)))\nBenchmarkTools.Trial: \n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     46.203 ns (0.00% GC)\n  median time:      46.415 ns (0.00% GC)\n  mean time:        47.467 ns (0.00% GC)\n  maximum time:     160.076 ns (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     988\n\njulia> 1.563e-6 / 46.415e-9\n33.67445868792416","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"So as long as SimHash reduces the size of the search space by 34 data points on average, it's faster than calculating the similarity between every pair of points. Even for our tiny dataset, which only had 100 points, that's still well worth it: with the 72/16/12 split that we got, SimHash reduces the number of similarities we have to calculate by 100 - left(frac72^2100 + frac16^2100 + frac12^2100right) approx 44 points on average.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"info: Improving LSH partitioning\nLSH can be poor at partitioning your input space when all of your data points are very similar to one another. In these cases, it may be helpful to find ways to transform your data in order to reduce their similarity.For instance, in the example above, we created a synthetic dataset with the following code:julia> data = ones(10,100);  # Each column is a data point\n\njulia> data[end,1:end] .= rand(100);  # Randomize the last dimension of each point These data are, for all practical purposes, one-dimensional. Their first nine dimensions are all the same; only the last dimension provides any unique information about a given data point. As a result, a dimensionality reduction technique like principal component analysis (PCA) would have helped de-correlate the dimensions of the data and thereby reduced the cosine similarity between pairs of points.","category":"page"},{"location":"#LSHFunctions.jl-1","page":"Home","title":"LSHFunctions.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"LSHFunctions.jl is a Julia package for performing locality-sensitive hashing with various similarity functions.","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"One of the simplest methods for classifying, categorizing, and grouping data is to measure how similar pairs of data points are. For instance, the classical k-nearest neighbors algorithm searches an input space X by taking a query point xin X and a similarity function","category":"page"},{"location":"#","page":"Home","title":"Home","text":"sXtimes XtomathbbR","category":"page"},{"location":"#","page":"Home","title":"Home","text":"It then computes s(xy) for every point y in a database, and keeps the k points that are closest to x.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Broadly, there are two computational issues with this approach:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"First, the database may be massive, much larger than could possibly fit in memory. This would make the brute-force approach of computing s(xy) for every point y in the database far too expensive to be practical.\nSecond, the dimensionality of the data may be such that computing s(xy) is itself expensive. In addition, the similarity function itself may simply be intrinsically difficult to compute. For instance, calculating Wasserstein distance entails solving a very high-dimensional linear program.","category":"page"},{"location":"#Locality-sensitive-hashing-1","page":"Home","title":"Locality-sensitive hashing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Locality-sensitive hashing (LSH) is a technique for accelerating similarity search that works by using a hash function on the query point x and limiting similarity search to only those points in the database that experience a hash collision with x. The hash functions that are used are randomly generated from a family of locality-sensitive hash functions. These hash functions have the property that Prh(x) = h(y) (i.e., the probability of a hash collision) increases the more similar that x and y are.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"LSHFunctions.jl is a package that provides definitions of locality-sensitive hash functions for a variety of different similarities. Currently, LSHFunctions.jl supports hash functions for","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Cosine similarity (cossim)\nJaccard similarity (jaccard)\nell^1 (Manhattan / \"taxicab\") distance (ℓ1)\nell^2 (Euclidean) distance (ℓ2)\nInner product (inner_prod)\nFunction-space hashes (L1, L2, and cossim)","category":"page"},{"location":"#Contents-1","page":"Home","title":"Contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"}]
}
