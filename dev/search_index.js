var documenterSearchIndex = {"docs":
[{"location":"similarities/lp_distance/#\\ellp-distance-1","page":"ell^p distance","title":"ell^p distance","text":"","category":"section"},{"location":"similarities/lp_distance/#L1Hash-and-L2Hash-1","page":"ell^p distance","title":"L1Hash and L2Hash","text":"","category":"section"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"L1Hash\nL2Hash","category":"page"},{"location":"similarities/lp_distance/#LSH.L1Hash","page":"ell^p distance","title":"LSH.L1Hash","text":"L1Hash(\n    n_hashes::Integer = 1;\n    dtype::DataType = Float32,\n    r::Real = 1.0,\n    resize_pow2::Bool = false\n)\n\nConstructs a locality-sensitive hash for ell^1 distance (x - y_1), defined as\n\nx - y_1 = sum_i x_i - y_i\n\nArguments\n\nn_hashes::Integer (default: 1): the number of hash functions to generate.\n\nKeyword parameters\n\ndtype::DataType (default: Float32): the data type to use in the L1Hash internals. For performance reasons you should pick dtype to match the type of the data you're hashing.\nr::Real (default: 1.0): a positive coefficient whose magnitude influences the collision rate. Larger values of r will increase the collision rate, even for distant points. See references for more information.\nresize_pow2::Bool (default: false): affects the way in which the returned L1Hash resizes to hash inputs of different sizes. If you think you'll be hashing inputs of many different sizes, it's more efficient to set resize_pow2 = true.\n\nExamples\n\nConstruct an L1Hash with the number of hash functions you want to generate:\n\njulia> hashfn = L1Hash(128);\n\njulia> hashfn.power == 1 &&\n       n_hashes(hashfn) == 128 &&\n       similarity(hashfn) == ℓ1\ntrue\n\nAfter creating a hash function, you can compute hashes with hashfn(x):\n\njulia> hashfn = L1Hash(20);\n\njulia> x = rand(4);\n\njulia> hashes = hashfn(x);\n\n\nReferences\n\nDatar, Mayur & Indyk, Piotr & Immorlica, Nicole & Mirrokni, Vahab. (2004). Locality-sensitive hashing scheme based on p-stable distributions. Proceedings of the Annual Symposium on Computational Geometry. 10.1145/997817.997857.\n\nSee also: ℓ1\n\n\n\n\n\n","category":"function"},{"location":"similarities/lp_distance/#LSH.L2Hash","page":"ell^p distance","title":"LSH.L2Hash","text":"L2Hash(\n    n_hashes::Integer = 1;\n    dtype::DataType = Float32,\n    r::Real = 1.0,\n    resize_pow2::Bool = false\n)\n\nConstructs a locality-sensitive hash for ell^2 distance (x - y_2), defined as\n\nx - y_2 = left(sum_i x_i - y_i^2right)^12\n\nArguments\n\nn_hashes::Integer (default: 1): the number of hash functions to generate.\n\nKeyword parameters\n\ndtype::DataType (default: Float32): the data type to use in the L2Hash internals. For performance reasons you should pick dtype to match the type of the data you're hashing.\nr::Real (default: 1.0): a positive coefficient whose magnitude influences the collision rate. Larger values of r will increase the collision rate, even for distant points. See references for more information.\nresize_pow2::Bool (default: false): affects the way in which the returned L2Hash resizes to hash inputs of different sizes. If you think you'll be hashing inputs of many different sizes, it's more efficient to set resize_pow2 = true.\n\nExamples\n\nConstruct an L2Hash with the number of hash functions you want to generate:\n\njulia> hashfn = L2Hash(128);\n\njulia> hashfn.power == 2 &&\n       n_hashes(hashfn) == 128 &&\n       similarity(hashfn) == ℓ2\ntrue\n\nAfter creating a hash function, you can compute hashes with hashfn(x):\n\njulia> hashfn = L2Hash(20);\n\njulia> x = rand(4);\n\njulia> hashes = hashfn(x);\n\n\nReferences\n\nDatar, Mayur & Indyk, Piotr & Immorlica, Nicole & Mirrokni, Vahab. (2004). Locality-sensitive hashing scheme based on p-stable distributions. Proceedings of the Annual Symposium on Computational Geometry. 10.1145/997817.997857.\n\nSee also: ℓ2\n\n\n\n\n\n","category":"function"},{"location":"similarities/lp_distance/#Utility-functions-1","page":"ell^p distance","title":"Utility functions","text":"","category":"section"},{"location":"similarities/lp_distance/#","page":"ell^p distance","title":"ell^p distance","text":"ℓp\nℓp_norm\nLp(::AbstractVector{T}, ::AbstractVector, ::Real) where T\nLp_norm(::AbstractVector, ::Real)","category":"page"},{"location":"similarities/lp_distance/#LSH.ℓp","page":"ell^p distance","title":"LSH.ℓp","text":"ℓp(x::AbstractVector, y::AbstractVector, p::Real=2)\nℓ1(x::AbstractVector, y::AbstractVector)\nℓ2(x::AbstractVector, y::AbstractVector)\n\nComputes the ell^p distance between a pair of vectors, given by\n\nell^p(xy) coloneqq x - y_p = left(sum_i leftx_i - y_iright^pright)^1p\n\nℓ1(x,y) is the same as ℓp(x,y,1), and ℓ2(x,y) is the same as ℓp(x,y,2).\n\nExamples\n\njulia> x = [1, 2, 3];\n\njulia> y = [4, 5, 6];\n\njulia> ℓp(x,y,2) == (abs(1-4)^2 + abs(2-5)^2 + abs(3-6)^2)^(1/2)\ntrue\n\njulia> ℓp(x,y,3) == (abs(1-4)^3 + abs(2-5)^3 + abs(3-6)^3)^(1/3)\ntrue\n\nSee also: ℓp_norm, L1Hash, L2Hash\n\n\n\n\n\n","category":"function"},{"location":"similarities/lp_distance/#LSH.ℓp_norm","page":"ell^p distance","title":"LSH.ℓp_norm","text":"ℓp_norm(x::AbstractVector, p::Real = 2)\nℓ1_norm(x::AbstractVector)\nℓ2_norm(x::AbstractVector)\n\nCompute the ell^p norm of a point x, defined as\n\nx_p = left(sum_i leftx_iright^pright)^1p\n\nExamples\n\njulia> x = randn(4);\n\njulia> ℓp_norm(x, 1) ≈ ℓ1_norm(x) ≈ (map(u -> abs(u)^1, x) |> sum)^(1/1)\ntrue\n\njulia> ℓp_norm(x, 2) ≈ ℓ2_norm(x) ≈ (map(u -> abs(u)^2, x) |> sum)^(1/2)\ntrue\n\njulia> ℓp_norm(x, 3) ≈ (map(u -> abs(u)^3, x) |> sum)^(1/3)\ntrue\n\nSee also: ℓp, Lp_norm\n\n\n\n\n\n","category":"function"},{"location":"similarities/lp_distance/#LSH.Lp-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1} where T,Real}} where T","page":"ell^p distance","title":"LSH.Lp","text":"Lp(x::AbstractVector, y::AbstractVector, p::Real=2)\nL1(x::AbstractVector, y::AbstractVector)\nL2(x::AbstractVector, y::AbstractVector)\n\nComputes the ℓ^p distance between a pair of vectors x and y. Identical to ℓp(x,y,p), ℓ1(x,y), and ℓ2(x,y), respectively.\n\nSee also: ℓp\n\n\n\n\n\n","category":"method"},{"location":"similarities/lp_distance/#LSH.Lp_norm-Tuple{AbstractArray{T,1} where T,Real}","page":"ell^p distance","title":"LSH.Lp_norm","text":"Lp_norm(x::AbstractVector, p::Real = 2)\nL1_norm(x::AbstractVector)\nL2_norm(x::AbstractVector)\n\nCompute the ell^p norm of a vector x. Identical to ℓp_norm(x,p), ℓ1_norm(x), and ℓ2_norm(x), respectively.\n\nSee also: ℓp_norm\n\n\n\n\n\n","category":"method"},{"location":"similarities/cosine/#Cosine-similarity-1","page":"Cosine similarity","title":"Cosine similarity","text":"","category":"section"},{"location":"similarities/cosine/#SimHash-1","page":"Cosine similarity","title":"SimHash","text":"","category":"section"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"SimHash","category":"page"},{"location":"similarities/cosine/#LSH.SimHash","page":"Cosine similarity","title":"LSH.SimHash","text":"SimHash(n_hashes::Integer = 1;\n        dtype::DataType = Float32,\n        resize_pow2::Bool = false)\n\nCreates a locality-sensitive hash function for cosine similarity.\n\nArguments\n\nn_hashes::Integer (default: 1): the number of hash functions to generate.\n\nKeyword parameters\n\ndtype::DataType (default: Float32): the data type to use in the LSH.SimHash internals. For performance reasons you should pick dtype to match the type of the data you're hashing.\nresize_pow2::Bool (default: false): affects the way in which the returned LSH.SimHash resizes to hash inputs of different sizes. If you think you'll be hashing inputs of many different sizes, it's more efficient to set resize_pow2 = true.\n\nExamples\n\nConstruct a hash function by calling SimHash with the number of hash functions you want to generate:\n\njulia> hashfn = SimHash(24);\n\njulia> n_hashes(hashfn) == 24 &&\n       similarity(hashfn) == cossim\ntrue\n\nYou can then call hashfn(x) in order to compute hashes:\n\njulia> hashfn = SimHash(32);\n\njulia> x = randn(30);\n\njulia> hashes = hashfn(x);\n\n\nReferences\n\nMoses S. Charikar. Similarity estimation techniques from rounding algorithms. In Proceedings of the Thiry-Fourth Annual ACM Symposium on Theory of Computing, STOC '02, page 380–388, New York, NY, USA, 2002. Association for Computing Machinery. 10.1145/509907.509965.\n\nSee also: cossim\n\n\n\n\n\n","category":"type"},{"location":"similarities/cosine/#Utilities-1","page":"Cosine similarity","title":"Utilities","text":"","category":"section"},{"location":"similarities/cosine/#","page":"Cosine similarity","title":"Cosine similarity","text":"cossim","category":"page"},{"location":"similarities/cosine/#LSH.cossim","page":"Cosine similarity","title":"LSH.cossim","text":"cossim(x,y)\n\nComputes the cosine similarity between two inputs x and y. Cosine similarity is defined as\n\ntextcossim(xy) = fracleftlangle xyrightranglexcdoty\n\nwhere leftlanglecdotcdotrightrangle is an inner product (e.g. dot product) and cdot is its derived norm. This is roughly interpreted as being related to the angle between the inputs x and y: when x and y have low angle between them, cossim(x,y) is high (close to 1). When x and y have large angle between them, cossim(x,y) is low (close to -1).\n\nArguments\n\nx and y: two inputs for which dot(x,y), norm(x), and norm(y) are defined.\n\nExamples\n\njulia> using LinearAlgebra: dot, norm;\n\njulia> x, y = rand(4), rand(4);\n\njulia> cossim(x,y) == dot(x,y) / (norm(x) * norm(y))\ntrue\n\njulia> z = rand(5);\n\njulia> cossim(x,z)\nERROR: DimensionMismatch(\"dot product arguments have lengths 4 and 5\")\n\nSee also: SimHash\n\n\n\n\n\n","category":"function"},{"location":"similarities/inner_prod/#Inner-product-similarity-1","page":"Inner product similarity","title":"Inner product similarity","text":"","category":"section"},{"location":"similarities/inner_prod/#SignALSH-1","page":"Inner product similarity","title":"SignALSH","text":"","category":"section"},{"location":"similarities/inner_prod/#","page":"Inner product similarity","title":"Inner product similarity","text":"SignALSH","category":"page"},{"location":"similarities/inner_prod/#LSH.SignALSH","page":"Inner product similarity","title":"LSH.SignALSH","text":"SignALSH(n_hashes::Integer = 1,\n         dtype::DataType = Float32,\n         maxnorm::Union{Nothing,Real} = nothing,\n         m::Integer = 3,\n         resize_pow2::Bool = false)\n\nCreate a SignALSH hash function for hashing on inner product similarity.\n\nArguments\n\nn_hashes::Integer (default: 1): the number of hash functions to generate.\n\nKeyword parameters\n\ndtype::DataType (default: Float32): the data type to use in the LSH.SignALSH internals. For performance reasons you should pick dtype to match the type of the data you're hashing.\nmaxnorm::Union{Nothing,Real} (default: nothing): an upper bound on the ell^2-norm of the data points. Note: this keyword argument must be explicitly specified. If it left unspecified (or set to nothing), SignALSH() will raise an error.\nm::Integer (default: 3): parameter m that affects the probability of a hash collision.\nresize_pow2::Bool (default: false): affects the way in which the returned LSH.SignALSH resizes to hash inputs of different sizes. If you think you'll be hashing inputs of many different sizes, it's more efficient to set resize_pow2 = true.\n\nExamples\n\nSignALSH is an AsymmetricLSHFunction, and hence hashes must be computed using index_hash and query_hash.\n\njulia> hashfn = SignALSH(12; maxnorm=10);\n\njulia> x = rand(4);\n\njulia> ih = index_hash(hashfn, x); qh = query_hash(hashfn, x);\n\njulia> length(ih) == length(qh) == 12\ntrue\n\njulia> typeof(ih) == typeof(qh) == BitArray{1}\ntrue\n\nYou need to explicitly specify the maxnorm keyword parameter when constructing SignALSH, otherwise you will get an error.\n\njulia> hashfn = SignALSH(12)\nERROR: maxnorm must be specified for SignALSH\n\nYou'll also get an error if you try to hash a vector that has norm greater than the maxnorm that you specified.\n\njulia> hashfn = SignALSH(; maxnorm=1);\n\njulia> index_hash(hashfn, ones(4))\nERROR: norm 2.0 exceeds maxnorm (1.0)\n\nReferences\n\nAnshumali Shrivastava and Ping Li. Improved Asymmetric Locality Sensitive Hashing (ALSH) for Maximum Inner Product Search (MIPS). In Proceedings of the Thirty-First Conference on Uncertainty in Artificial Intelligence, UAI'15, page 812–821, Arlington, Virginia, USA, 2015. AUAI Press. 10.5555/3020847.3020931. https://arxiv.org/abs/1410.5410v2\n\nSee also: inner_prod, ℓ2_norm\n\n\n\n\n\n","category":"type"},{"location":"similarities/inner_prod/#MIPSHash-1","page":"Inner product similarity","title":"MIPSHash","text":"","category":"section"},{"location":"similarities/inner_prod/#","page":"Inner product similarity","title":"Inner product similarity","text":"MIPSHash","category":"page"},{"location":"similarities/inner_prod/#LSH.MIPSHash","page":"Inner product similarity","title":"LSH.MIPSHash","text":"MIPSHash(n_hashes::Integer = 1;\n         dtype::Datatype = Float32,\n         maxnorm::Union{Nothing,Real} = nothing,\n         scale::Real = 1,\n         m::Integer = 3,\n         resize_pow2::Bool = false)\n\nCreate a MIPSHash hash function for hashing on inner product similarity.\n\nArguments\n\nn_hashes::Integer (default: 1): the number of hash functions to generate.\n\nKeyword parameters\n\ndtype::DataType (default: Float32): the data type to use in the LSH.MIPSHash internals. For performance reasons you should pick dtype to match the type of the data you're hashing.\nmaxnorm::Union{Nothing,Real} (default: nothing): an upper bound on the ell^2-norm of the data points. Note: this keyword argument must be explicitly specified. If it left unspecified (or set to nothing), MIPSHash() will raise an error.\nscale::Real (default: 1): parameter that affects the probability of a hash collision. Large values of scale increases hash collision probability (even for inputs with low inner product similarity); small values of scale will decrease hash collision probability.\n\nExamples\n\nMIPSHash is an AsymmetricLSHFunction, and hence hashes must be computed using index_hash and query_hash.\n\njulia> hashfn = MIPSHash(5; maxnorm=10);\n\njulia> x = rand(4);\n\njulia> ih = index_hash(hashfn, x); qh = query_hash(hashfn, x);\n\njulia> length(ih) == length(qh) == 5\ntrue\n\njulia> typeof(ih) == typeof(qh) == Vector{Int32}\ntrue\n\nYou need to explicitly specify the maxnorm keyword parameter when constructing MIPSHash, otherwise you will get an error.\n\njulia> hashfn = MIPSHash(5)\nERROR: maxnorm must be specified for MIPSHash\n\nYou'll also get an error if you try to hash a vector that has norm greater than the maxnorm that you specified.\n\njulia> hashfn = MIPSHash(; maxnorm=1);\n\njulia> index_hash(hashfn, ones(4))\nERROR: norm 2.0 exceeds maxnorm (1.0)\n\nReferences\n\nAnshumali Shrivastava and Ping Li. Asymmetric LSH (ALSH) for Sublinear Time Maximum Inner Product Search (MIPS). Proceedings of the 27th International Conference on Neural Information Processing Systems - Volume 2, NIPS'14, page 2321–2329, Cambridge, MA, USA, 2014. MIT Press. 10.5555/2969033.2969086. https://arxiv.org/abs/1405.5869\n\nSee also: inner_prod, ℓ2_norm\n\n\n\n\n\n","category":"type"},{"location":"similarities/inner_prod/#Utilities-1","page":"Inner product similarity","title":"Utilities","text":"","category":"section"},{"location":"similarities/inner_prod/#","page":"Inner product similarity","title":"Inner product similarity","text":"inner_prod(::AbstractVector, ::AbstractVector)","category":"page"},{"location":"similarities/inner_prod/#LSH.inner_prod-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Inner product similarity","title":"LSH.inner_prod","text":"inner_prod(x::AbstractVector, y::AbstractVector)\n\nComputes the ell^2 inner product (dot product)\n\nleftlangle x yrightrangle = sum_i x_iy_i\n\nExamples\n\njulia> using LinearAlgebra: dot;\n\njulia> x, y = randn(4), randn(4);\n\njulia> inner_prod(x,y) ≈ dot(x,y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#LSH.jl-1","page":"Home","title":"LSH.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"LSH.jl is a Julia package for performing locality-sensitive hashing with various similarity functions.","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"One of the simplest methods for classifying, categorizing, and grouping data is to measure how similarities pairs of data points are. For instance, the classical k-nearest neighbors algorithm takes a similarity function","category":"page"},{"location":"#","page":"Home","title":"Home","text":"sXtimes XtomathbbR","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and a query point xin X, where X is the input space. It then computes s(xy) for every point y in a database, and keeps the k points that are closest to x.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Broadly, there are two computational issues with this approach:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"First, the database may be massive, much larger than could possibly fit in memory. This would make the brute-force approach of computing s(xy) for every point y in the database far too expensive to be practical.\nSecond, the dimensionality of the data may be such that computing s(xy) is itself expensive. In addition, the similarity function itself may simply be intrinsically difficult to compute. For instance, calculating Wasserstein distance entails solving a very high-dimensional linear program.","category":"page"},{"location":"#Locality-sensitive-hashing-1","page":"Home","title":"Locality-sensitive hashing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Locality-sensitive hashing (LSH) is a technique for accelerating similarity search that works by using a hash function on the query point x and limiting similarity search to only those points in the database that experience a hash collision with x. The hash functions that are used are randomly generated from a family of locality-sensitive hash functions. These hash functions have the property that Prh(x) = h(y) (i.e., the probability of a hash collision) increases the more similar that x and y are.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"LSH.jl is a package that provides definitions of locality-sensitive hash functions for a variety of different similarities. Currently, LSH.jl supports hash functions for","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Cosine similarity (cossim)\nJaccard similarity (jaccard)\nL^1 (Manhattan / \"taxicab\") distance (ℓ1)\nL^2 (Euclidean) distance (ℓ2)\nInner product (inner_prod)\nFunction-space hashes (L1, L2, and cossim)","category":"page"},{"location":"#Contents-1","page":"Home","title":"Contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"similarities/jaccard/#Jaccard-similarity-1","page":"Jaccard similarity","title":"Jaccard similarity","text":"","category":"section"},{"location":"similarities/jaccard/#MinHash-1","page":"Jaccard similarity","title":"MinHash","text":"","category":"section"},{"location":"similarities/jaccard/#","page":"Jaccard similarity","title":"Jaccard similarity","text":"MinHash","category":"page"},{"location":"similarities/jaccard/#LSH.MinHash","page":"Jaccard similarity","title":"LSH.MinHash","text":"MinHash(n_hashes::Integer = 1;\n        dtype::DataType = Any,\n        symbols::Union{Vector,Set} = Set())\n\nConstruct a locality-sensitive hash function for Jaccard similarity.\n\nArguments\n\nn_hashes::Integer (default: 1): the number of hash functions to generate.\n\nKeyword parameters\n\ndtype::DataType (default: Any): the type of symbols in the sets you're hashing. This is overriden by the data type contained in symbols when symbols is non-empty.\nsymbols::Union{Vector,Set}: a Vector or Set containing all of the possible elements (\"symbols\") of the sets that you will be hashing. If left empty, MinHash will instead expand its dictionary when it sees new symbols (at small additional computational expense).\n\nExamples\n\nConstruct a hash function to hash sets whose elements are integers between 1 and 50:\n\njulia> hashfn = MinHash(40; symbols = Set(1:50));\n\njulia> n_hashes(hashfn) == 40 && similarity(hashfn) == jaccard\ntrue\n\njulia> hashfn(Set([38, 14, 29, 48, 11]));\n\njulia> hashfn([1, 1, 2, 3, 4]); # You can also hash Vectors\n\njulia> hashfn(Set([100]))\nERROR: Symbol 100 not found\n\nIf you aren't sure ahead of time exactly what kinds of elements will be in the sets you're hashing, you can opt not to specify symbols, in which case MinHash will lazily update its hash functions as it encounters new symbols:\n\njulia> hashfn = MinHash();\n\njulia> hashfn(Set([1, 2, 3]));\n\njulia> hashfn(Set([\"a\", \"b\", \"c\"]));\n\n\nIf you don't know what elements you'll encounter, but you know that they'll all be of a specific data type, you can specify the dtype argument for increased efficiency:\n\njulia> hashfn = MinHash(10; dtype = String);\n\njulia> hashfn(Set([\"a\", \"b\", \"c\"]));\n\n\nReferences\n\nBroder, A. On the resemblance and containment of documents. Compression and Complexity of Sequences: Proceedings, Positano, Amalfitan Coast, Salerno, Italy, June 11-13, 1997. doi:10.1109/SEQUEN.1997.666900.\n\nSee also: jaccard\n\n\n\n\n\n","category":"type"},{"location":"similarities/jaccard/#Utilities-1","page":"Jaccard similarity","title":"Utilities","text":"","category":"section"},{"location":"similarities/jaccard/#","page":"Jaccard similarity","title":"Jaccard similarity","text":"jaccard","category":"page"},{"location":"similarities/jaccard/#LSH.jaccard","page":"Jaccard similarity","title":"LSH.jaccard","text":"jaccard(A::Set, B::Set) :: Float64\n\nComputes the Jaccard similarity between sets A and B, which is defined as\n\ntextJaccard(AB) = fracleftA cap BrightleftA cup Bright\n\nArguments\n\nA::Set, B::Set: the two sets with which to compute Jaccard similarity.\n\nReturns\n\nFloat64: the Jaccard similarity between sets A and B, which is between 0 and 1.\n\nExamples\n\njulia> A, B = Set([1, 2, 3]), Set([2, 3, 4]);\n\njulia> jaccard(A,B)\n0.5\n\njulia> jaccard(A,B) == length(A ∩ B) / length(A ∪ B)\ntrue\n\nSee also: MinHash\n\n\n\n\n\n","category":"function"}]
}
